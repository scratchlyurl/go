<script>

document.write('Redirecting...');

// VARIABLES
// scratch.us.to/[type]*****
// scratch.us.to/[fullinfo]
// scratch.us.to/*[info]


var url = document.location.toString();
var search = url.search('#')+2;
var nfullinfo = url.substring(search, search+200);
var ninfo = url.substring(search+1, search+200);
var info = $d.decodeBase62(ninfo);
var fullinfo = $d.decodeBase62(nfullinfo);


var info2 = info.split('/').join('');

var type = nfullinfo.substring(0,1);

console.log('Info: ' + info);
console.log('Type: ' + type);
console.log('Info2: ' + info2);

switch(type) {

case 'p':
window.location = "https://scratch.mit.edu/projects/" + info;      break;


case 'e':
window.location = "https://scratch.mit.edu/projects/" + info2 + "/#editor";      break;


case 'f':
window.location = "https://scratch.mit.edu/projects/" + info2 + "/#fullscreen";      break;



case 's':
window.location = "https://scratch.mit.edu/studios/" + info;       break;


case 'c':
window.location = "https://scratch.mit.edu/studios/" + info2 + '/comments/';       break;


case 'm':
window.location = "https://scratch.mit.edu/studios/" + info2 + '/curators/';       break;


case 'a':
window.location = "https://scratch.mit.edu/studios/" + info2 + '/activity/';      break;



case 'd':
window.location = "https://scratch.mit.edu/discuss/" + ninfo;       break;


case 't':
window.location = "https://scratch.mit.edu/discuss/topic/" + info;       break;




case '@':
window.location = "https://scratch.mit.edu/users/" + ninfo;      break;


case '.':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/projects/";      break;


case ',':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/favorites/";      break;


case ':':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/studios_following/";      break;


case '*':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/studios/";      break;


case ';':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/following/";      break;

case '+':
window.location = "https://scratch.mit.edu/users/" + ninfo + "/followers/";      break;




case '-':
window.location = "https://scratch.mit.edu/" + ninfo;      break;




case '?':
window.location = "https://wiki.scratch.mit.edu/wiki/" + ninfo;      break;



case 'y':
window.location = "https://scratch.mit.edu/discuss/youtube/" + ninfo + "/";      break;




    default:
window.location = "https://scratchlyurl.github.io/shortener/";}        











































/**
 * Base62 Encoding JavaScript implementation
 * 
 * @author odan (https://github.com/odan)
 * @license: MIT
 * 
 * Thanks to: renmengye
 * https://github.com/renmengye/base62-csharp
 * 
 * @example 
 * 
 * // encode
 * var strBase62 = $d.encodeBase62('test123');
 * console.log(strBase62);
 * 
 * // decode
 * var strText = $d.decodeBase62(strBase62);
 * console.log(strText);
 * 
 */

// Namespace stuff
if (!$d) {
    var $d = {};
}


/**
 * Utility that read and write bits in byte array
 * @param {type} options
 * @returns {BitStream}
 */
$d.BitStream = function BitStream(options) {
    this.Source = [];

    if (typeof options === 'object') {
        // Initialize the stream with a source byte array
        this.Source = options;
    }

    if (typeof options === 'number') {
        // Initialize the stream with capacity
        var dim = Math.floor(options);
        this.Source = new Array(dim);
    }

    // Bit position of the stream
    this.Position = 0;

    /**
     * Bit length of the stream
     * @returns {Number|@pro;length@this.Source}
     */
    this.Length = function() {
        return this.Source.length * 8;
    };

    /**
     * Read the stream to the buffer
     * @param {Array} buffer Buffer
     * @param {integer} offset Offset bit start position of the stream
     * @param {integer} count Number of bits to read
     * @returns {integer} Number of bits read
     */
    this.Read = function(buffer, offset, count) {
        // Temporary position cursor
        var tempPos = this.Position;
        tempPos += offset;
        // Buffer byte position and in-byte position
        var readPosCount = 0;
        var readPosMod = 0;
        // Stream byte position and in-byte position
        var posCount = tempPos >> 3;
        var posMod = (tempPos - ((tempPos >> 3) << 3));
        while (tempPos < this.Position + offset + count && tempPos < this.Length()) {
            // Copy the bit from the stream to buffer
            if (((this.Source[posCount]) & (0x1 << (7 - posMod))) != 0) {
                buffer[readPosCount] = ((buffer[readPosCount]) | (0x1 << (7 - readPosMod)));
            } else {
                buffer[readPosCount] = ((buffer[readPosCount]) & (0xffffffff - (0x1 << (7 - readPosMod))));
            }

            // Increment position cursors
            tempPos++;
            if (posMod == 7) {
                posMod = 0;
                posCount++;
            } else {
                posMod++;
            }
            if (readPosMod == 7) {
                readPosMod = 0;
                readPosCount++;
            } else {
                readPosMod++;
            }
        }
        var bits = (tempPos - this.Position - offset);
        this.Position = tempPos;
        return bits;
    };

    /**
     * Set up the stream position
     * @param {integer} offset Position
     * @param {integer} origin Position origin
     * @returns {integer} Position after setup
     */
    this.Seek = function(offset, origin) {
        switch (origin) {
            case (1):
                /*SeekOrigin.Begin*/ {
                    this.Position = offset;
                    break;
                }
            case (2):
                /*SeekOrigin.Current*/ {
                    this.Position += offset;
                    break;
                }
            case (3):
                /*SeekOrigin.End*/ {
                    this.Position = this.Length() + offset;
                    break;
                }
        }
        return this.Position;
    };

    /**
     * Write from buffer to the stream
     * @param {type} buffer
     * @param {type} offset Offset start bit position of buffer
     * @param {type} count
     * @returns {undefined} Number of bits
     */
    this.Write = function(buffer, offset, count) {
        // Temporary position cursor
        var tempPos = this.Position;
        // Buffer byte position and in-byte position
        var readPosCount = offset >> 3,
                readPosMod = offset - ((offset >> 3) << 3);
        // Stream byte position and in-byte position
        var posCount = tempPos >> 3;
        var posMod = (tempPos - ((tempPos >> 3) << 3));
        while (tempPos < this.Position + count && tempPos < this.Length()) {
            // Copy the bit from buffer to the stream
            if (((buffer[readPosCount]) & (0x1 << (7 - readPosMod))) != 0) {
                this.Source[posCount] = ((this.Source[posCount]) | (0x1 << (7 - posMod)));
            } else {
                this.Source[posCount] = ((this.Source[posCount]) & (0xffffffff - (0x1 << (7 - posMod))));
            }

            // Increment position cursors
            tempPos++;
            if (posMod == 7) {
                posMod = 0;
                posCount++;
            } else {
                posMod++;
            }
            if (readPosMod == 7) {
                readPosMod = 0;
                readPosCount++;
            } else {
                readPosMod++;
            }
        }
        this.Position = tempPos;
    };
};


/**
 * Base62 Coding Space
 * @type String
 */
$d.Base62CodingSpace = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

/**
 * Convert a byte array
 * @param {String} original Byte array
 * @returns {unresolved} Base62 string
 */
$d.encodeBase62ToString = function encodeBase62ToString(original) {
    var sb = []; // new StringBuilder();
    var stream = new $d.BitStream(original); // Set up the BitStream
    var read = []; // Only read 6-bit at a time
    read.push(0);

    while (true) {
        read[0] = 0;

        var length = stream.Read(read, 0, 6); // Try to read 6 bits
        if (length == 6) // Not reaching the end
        {
            if ((read[0] >> 3) == 0x1f) // First 5-bit is 11111
            {
                sb.push($d.Base62CodingSpace.charAt(61));
                stream.Seek(-1, 2 /*SeekOrigin.Current*/); // Leave the 6th bit to next group
            } else if ((read[0] >> 3) == 0x1e) // First 5-bit is 11110
            {
                sb.push($d.Base62CodingSpace.charAt(60));
                stream.Seek(-1, 2 /*SeekOrigin.Current*/);
            } else // Encode 6-bit
            {
                sb.push($d.Base62CodingSpace.charAt((read[0] >> 2)));
            }
        } else {
            // Padding 0s to make the last bits to 6 bit
            sb.push($d.Base62CodingSpace.charAt((read[0] >> (8 - length))));
            break;
        }
    }
    var str = sb.join('');
    return str;
};

/**
 * Convert a Base62 string to byte array
 * @param {type} base62 Base62 string
 * @returns {Array} Byte array
 */
$d.decodeBase62ToArray = function decodeBase62ToArray(base62) {
    // Character count
    var count = 0;

    // Set up the BitStream
    var stream = new $d.BitStream(base62.length * 6 / 8);
	var len = base62.length;
    for (var i = 0; i < len; i++) {
		
        var c = base62.charAt(i);
        // Look up coding table
        var index = $d.Base62CodingSpace.indexOf(c);

        // If end is reached
        if (count == base62.length - 1) {
            // Check if the ending is good
            var mod = (stream.Position % 8);
            stream.Write([(index << (mod))], 0, 8 - mod);
        } else {
            // If 60 or 61 then only write 5 bits to the stream, otherwise 6 bits.
            if (index == 60) {
                //stream.Write(new byte[] { 0xf0 }, 0, 5);
                stream.Write([0xf0], 0, 5);
            } else if (index == 61) {
                stream.Write([0xf8], 0, 5);
            } else {
                stream.Write([index], 2, 6);
            }
        }
        count++;
    }

    // Dump out the bytes
    var result = new Array(stream.Position / 8);
    stream.Seek(0, 1 /* SeekOrigin.Begin*/);
    stream.Read(result, 0, result.length * 8);
    return result;
};

/**
 * Encodes data with base62
 * @param {String} str The data to encode.
 * @returns {String}
 */
$d.encodeBase62 = function encodeBase62(str) {
    
    if (typeof str !== 'string' || str === '') {
        return '';
    }
    
    str = str.toString();
	
    var bytes = [];
	var len = str.length;
    for (var i = 0; i < len; i++) {
        bytes.push(str.charCodeAt(i));
    }

    var strReturn = this.encodeBase62ToString(bytes);
    return strReturn;
};

/**
 * Decodes a base62 encoded data.
 * @param {String} str
 * @returns {String} Returns the original data or false on failure. 
 * The returned data may be binary.
 */
$d.decodeBase62 = function decodeBase62(str) {
    
    if (typeof str !== 'string' || str === '') {
        return '';
    }
    
    str = str.toString();

    var bytes = this.decodeBase62ToArray(str);
    var sb = [];
	var len = bytes.length;
	
    for (var i = 0; i < len; i++) {
        sb.push(String.fromCharCode(bytes[i]));
    }
    str = sb.join('');
    return str;
};

/**
 * jQuery Plugin - Base62 Encoding
 * 
 * @example 
 * var strBase62 = $.encodeBase62('test123');
 * var strText = $.decodeBase62(strBase62);
 */
(function($) {

    /**
     * Encodes data with base62
     * @param {String} str The data to encode.
     * @returns {String}
     */
    $.encodeBase62 = function encodeBase62(str) {
        return $d.encodeBase62(str);
    };

    /**
     * Decodes a base62 encoded data.
     * @param {String} str
     * @returns {String} Returns the original data or false on failure. 
     * The returned data may be binary.
     */
    $.decodeBase62 = function decodeBase62(str) {
        return $d.decodeBase62(str);
    };


})(jQuery);






</script>
